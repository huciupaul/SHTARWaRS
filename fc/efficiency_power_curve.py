import numpy as np
from scipy.interpolate import CubicSpline
import matplotlib.pyplot as plt
import pickle

# -------------------------------------------------------------------
# 1) "Digitized" (j, η) pairs for T=473 K (green‐square curve).
#
#    These 18 points were extracted by finding green‐square centroids
#    in the provided plot and mapping pixel‐coordinates back to data‐units.
#    You can tweak or add more points if you want a finer fit.
#   https://doi.org/10.1016/j.seta.2022.102232
# -------------------------------------------------------------------
#
#   (j in A/m²,   η in %)

j_data = 20000 * np.array([0, 0.010121457177244596, 0.03238867068924164, 0.05566801447484513, 0.07692309771323576, 0.10829959951857593, 0.13765184077670323, 0.16700404342453545, 0.19028342582043403, 0.22064779735216775, 0.25607289747252376, 0.28036441014202873, 0.31072878167376244, 0.3562753389713631, 0.39271256936532545, 0.42206481062345275, 0.45242918215518646, 0.4898785428227554, 0.5283401109845208, 0.5647773413784832, 0.6022267020460521, 0.654858325700078, 0.692307686367647, 0.7297570470352158, 0.7601214185669496, 0.7894736598250769, 0.8198380313568105, 0.8572873920243795, 0.8876517635561131, 0.90283394932198, 0.9170040820348304, 0.940283464430729, 0.9554656501965959, 0.9696356284682661, 0.9777328250982981, 0.9848178142341331, 0.9929150108641647])
eta_data = 7/6* 0.01 * np.array([77.5, 70.03027577703709, 63.85380474719604, 60.82612309628746, 58.888406377718425, 56.95069196908716, 55.37629843458981, 54.0441157362647, 53.196363950035185, 52.22750674571955, 51.016434085356124, 50.4108977551744, 49.563145968944895, 48.47318334654315, 47.625431560313636, 46.89878981204581, 46.29325348186409, 45.445501695634576, 44.59774990940506, 43.74999812317555, 42.902246336946035, 41.691173676582615, 40.84342651022866, 39.99567472399915, 39.14792293776963, 38.30017115154012, 37.452419365310604, 36.12024128686106, 34.78806320841151, 34.06141684026811, 33.33477509200028, 31.881486975589052, 30.42819885917783, 28.732699906594362, 27.40051720826925, 25.46280279963799, 22.67733660477722])

j_data_2 = 20000 * np.array([0, 0.05353534789173427, 0.09898989509774776, 0.12929292656842345, 0.17474747377443692, 0.24949496681502242, 0.3090909441202701, 0.35353540569017994, 0.4141414686315313, 0.4595960158375447, 0.5121212395608782, 0.5646464632842118, 0.6171717640721395, 0.6545454720601351, 0.6919192571127248, 0.7292929651007205, 0.7737374266706305, 0.7969697045593919, 0.8343434896119817, 0.8717171975999773, 0.9020202290706529])
P_data = np.array([0, 1000.0002825701673, 1685.1849026150162, 2129.629629629629, 2759.258835404007, 3740.7408820258233, 4481.481622766564, 5018.518235948349, 5685.185326470269, 6166.666525381584, 6703.703844988788, 7203.7032798484515, 7666.666242811414, 7962.962962962962, 8240.74074074074, 8499.999222932038, 8759.259117974176, 8851.851710566769, 8981.481481481482, 9037.036895751953, 8981.481481481482]) / 9037.036895751953


# -------------------------------------------------------------------
# Points from Lorenzo 
# --------------------------------------------------------------------

V = np.array([1.320000, 0.918729, 0.888944, 0.870336, 0.856300, 0.844766, 0.834811, 0.825943, 0.817869, 0.810399, 0.803403, 0.796790, 0.790490, 0.784453, 0.778637, 0.773012, 0.767550, 0.762231, 0.757037, 0.751954, 0.746969, 0.742071, 0.737251, 0.732502, 0.727815, 0.723186, 0.718608, 0.714076, 0.709587, 0.705136, 0.700719, 0.696334, 0.691977, 0.687647, 0.683339, 0.679053, 0.674785, 0.670534, 0.666298, 0.662076, 0.657865, 0.653665, 0.649473, 0.645288, 0.641110, 0.636936, 0.632766, 0.628598, 0.624432, 0.620266, 0.616099, 0.611931, 0.607760, 0.603585, 0.599405, 0.595220, 0.591029, 0.586830, 0.582624, 0.578408, 0.574182, 0.569945, 0.565697, 0.561436, 0.557162, 0.552873, 0.548569, 0.544250, 0.539913, 0.535558, 0.531184, 0.526791, 0.522376, 0.517940, 0.513481, 0.508998, 0.504491, 0.499957, 0.495396, 0.490806, 0.486187, 0.481537, 0.476854, 0.472138, 0.467387, 0.462600, 0.457774, 0.452909, 0.448002, 0.443053, 0.438058, 0.433016, 0.427926, 0.422784, 0.417589, 0.412339, 0.407029, 0.401659, 0.396225, 0.390725, 0.385154, 0.379510, 0.373788, 0.367986, 0.362098, 0.356121, 0.350049, 0.343878, 0.337601, 0.331214, 0.324708, 0.318077, 0.311314, 0.304409, 0.297355, 0.290139, 0.282752, 0.275181, 0.267411, 0.259429, 0.251216, 0.242754, 0.234021, 0.224992, 0.215639, 0.205930, 0.195829, 0.185291, 0.174266, 0.162695, 0.150506, 0.137611, 0.123905, 0.109255, 0.093495, 0.076409, 0.057712, 0.037015, 0.013773])
i = np.array([0, 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1, 0.11, 0.12, 0.13, 0.14, 0.15, 0.16, 0.17, 0.18, 0.19, 0.2, 0.21, 0.22, 0.23, 0.24, 0.25, 0.26, 0.27, 0.28, 0.29, 0.3, 0.31, 0.32, 0.33, 0.34, 0.35, 0.36, 0.37, 0.38, 0.39, 0.4, 0.41, 0.42, 0.43, 0.44, 0.45, 0.46, 0.47, 0.48, 0.49, 0.5, 0.51, 0.52, 0.53, 0.54, 0.55, 0.56, 0.57, 0.58, 0.59, 0.6, 0.61, 0.62, 0.63, 0.64, 0.65, 0.66, 0.67, 0.68, 0.69, 0.7, 0.71, 0.72, 0.73, 0.74, 0.75, 0.76, 0.77, 0.78, 0.79, 0.8, 0.81, 0.82, 0.83, 0.84, 0.85, 0.86, 0.87, 0.88, 0.89, 0.9, 0.91, 0.92, 0.93, 0.94, 0.95, 0.96, 0.97, 0.98, 0.99, 1, 1.01, 1.02, 1.03, 1.04, 1.05, 1.06, 1.07, 1.08, 1.09, 1.1, 1.11, 1.12, 1.13, 1.14, 1.15, 1.16, 1.17, 1.18, 1.19, 1.2, 1.21, 1.22, 1.23, 1.24, 1.25, 1.26, 1.27, 1.28, 1.29, 1.3, 1.31, 1.32, 1.33, 1.34, 1.35, 1.36, 1.37, 1.38])
P_data_realest2 = np.array([0, 0.00918729, 0.017778872, 0.02611008, 0.034252009, 0.042238298, 0.050088657, 0.057816023, 0.065429515, 0.072935883, 0.080340305, 0.087646856, 0.094858817, 0.101978867, 0.109009223, 0.115951737, 0.122807972, 0.12957925, 0.136266694, 0.142871263, 0.149393776, 0.155834928, 0.162195313, 0.168475429, 0.174675697, 0.180796462, 0.186838009, 0.192800561, 0.19868429, 0.204489319, 0.210215725, 0.215863545, 0.221432777, 0.226923384, 0.232335291, 0.237668394, 0.242922558, 0.248097615, 0.25319337, 0.258209602, 0.263146061, 0.26800247, 0.272778526, 0.277473903, 0.282088246, 0.286621176, 0.29107229, 0.295441159, 0.299727326, 0.303930314, 0.308049614, 0.312084695, 0.316034998, 0.319899937, 0.323678899, 0.327371242, 0.330976295, 0.334493357, 0.337921698, 0.341260555, 0.344509134, 0.347666604, 0.350732104, 0.353704733, 0.356583554, 0.359367593, 0.362055831, 0.364647212, 0.367140631, 0.369534941, 0.371828944, 0.374021394, 0.37611099, 0.378096377, 0.379976142, 0.38174881, 0.383412842, 0.384966631, 0.386408499, 0.387736692, 0.388949376, 0.390044633, 0.391020456, 0.391874742, 0.392605288, 0.393209783, 0.393685805, 0.394030808, 0.394242117, 0.39431692, 0.394252256, 0.394045007, 0.393691885, 0.39318942, 0.392533946, 0.391721589, 0.390748243, 0.389609561, 0.388300929, 0.386817445, 0.385153895, 0.383304726, 0.381264014, 0.379025432, 0.376582209, 0.373927092, 0.371052292, 0.367949435, 0.364609496, 0.361022732, 0.357178604, 0.353065681, 0.34867154, 0.343982643, 0.338984198, 0.333659999, 0.327992232, 0.321961258, 0.315545345, 0.308720358, 0.301459385, 0.293732289, 0.28550516, 0.276739654, 0.267392166, 0.257412816, 0.246744161, 0.235319568, 0.223061114, 0.209876854, 0.195657195, 0.180270021, 0.163553988, 0.14530912, 0.12528327, 0.103152034, 0.078487937, 0.05071112, 0.019006373])
da_realest_spline2 = CubicSpline(i, V, bc_type='natural')
da_realest_spline3 = CubicSpline(i, P_data_realest2, bc_type='natural')
P_data_realest = 1/0.414391884 * np.array([0.00919735, 0.017800821, 0.026145782, 0.034303366, 0.042307252, 0.050177189, 0.057926157, 0.065563316, 0.07309546, 0.080527811, 0.087864492, 0.09510883, 0.102263553, 0.109330928, 0.11631286, 0.123210964, 0.130026616, 0.136760998, 0.143415126, 0.149989878, 0.156486013, 0.162904186, 0.169244963, 0.175508831, 0.181696207, 0.187807446, 0.193842848, 0.19980266, 0.205687084, 0.211496281, 0.217230372, 0.222889443, 0.228473547, 0.233982703, 0.239416905, 0.244776116, 0.250060274, 0.255269292, 0.260403059, 0.26546144, 0.270444278, 0.275351397, 0.280182595, 0.284937653, 0.289616332, 0.294218369, 0.298743487, 0.303191384, 0.307561742, 0.311854223, 0.316068469, 0.320204101, 0.324260724, 0.328237919, 0.332135251, 0.335952262, 0.339688474, 0.343343388, 0.346916484, 0.35040722, 0.353815031, 0.357139331, 0.360379508, 0.363534928, 0.366604931, 0.369588832, 0.372485918, 0.375295452, 0.378016666, 0.380648763, 0.383190917, 0.38564227, 0.388001932, 0.390268977, 0.392442447, 0.394521343, 0.396504633, 0.39839124, 0.400180048, 0.401869896, 0.403459579, 0.404947843, 0.406333383, 0.407614842, 0.408790809, 0.409859814, 0.410820324, 0.411670744, 0.412409411, 0.41303459, 0.413544469, 0.413937158, 0.414210683, 0.414362978, 0.414391884])
eta_data_realest = 6/7*np.array([0.733966401, 0.710269997, 0.695494687, 0.684368782, 0.675240145, 0.667372831, 0.660374232, 0.654009967, 0.648128826, 0.642627543, 0.637432438, 0.632489085, 0.627756136, 0.623201429, 0.618799449, 0.614529612, 0.610375062, 0.606321821, 0.602358163, 0.598474153, 0.594661295, 0.590912266, 0.587220702, 0.58358104, 0.579988384, 0.576438398, 0.572927225, 0.569451415, 0.566007865, 0.562593775, 0.559206608, 0.555844053, 0.552503999, 0.54918451, 0.545883805, 0.542600239, 0.539332288, 0.536078537, 0.532837665, 0.529608439, 0.526389701, 0.523180364, 0.519979402, 0.516785845, 0.513598773, 0.510417311, 0.507240627, 0.504067923, 0.500898436, 0.497731433, 0.494566208, 0.491402079, 0.488238385, 0.485074488, 0.481909763, 0.478743604, 0.475575417, 0.472404621, 0.469230644, 0.466052925, 0.462870909, 0.459684049, 0.456491801, 0.453293626, 0.450088989, 0.446877353, 0.443658186, 0.440430951, 0.437195113, 0.433950133, 0.430695466, 0.427430567, 0.424154883, 0.420867852, 0.417568908, 0.414257475, 0.410932967, 0.407594786, 0.404242325, 0.400874961, 0.397492057, 0.394092963, 0.390677009, 0.387243508, 0.383791755, 0.38032102, 0.376830556, 0.373319586, 0.36978731, 0.366232901, 0.362655499, 0.359054215, 0.355428124, 0.351776266, 0.34809764])
da_realest_spline = CubicSpline(P_data_realest, eta_data_realest, bc_type='natural', extrapolate=True)


# Just to confirm we have 18 points:
# assert j_data.shape == eta_data.shape == (18,)
# -------------------------------------------------------------------
# 2) Build a cubic spline over [0, 20 000].
#
#    By default we will do a "natural" spline (second 
#    derivative = 0 at the two ends). If you want a different boundary
#    condition (e.g. "clamped"), you can pass bc_type="clamped" etc.
# -------------------------------------------------------------------
#
spline = CubicSpline(j_data, eta_data, bc_type='natural', extrapolate=True)
def eta_of_j(j):
    """
    Return the interpolated energy‐efficiency [%%] at current density j [A/m²]
    using a cubic‐spline based on the digitized T=473 K curve. 
    Returns NaN if j < 0 or j > 20 000 (no extrapolation).
    """
    j = np.atleast_1d(j)
    out = np.full_like(j, np.nan, dtype=float)
    mask = (j >= j_data.min()) & (j <= j_data.max())
    if np.any(mask):
        out[mask] = spline(j[mask])
    return out if out.shape != () else out.item()

spline2 = CubicSpline(j_data_2, P_data, bc_type='natural', extrapolate=True)
def P_of_j(j):
    """
    Return the interpolated power [W] at current density j [A/m²]
    using a cubic‐spline based on the digitized T=473 K curve. 
    Returns NaN if j < 0 or j > 20 000 (no extrapolation).
    """
    j = np.atleast_1d(j)
    out = np.full_like(j, np.nan, dtype=float)
    mask = (j >= j_data_2.min()) & (j <= j_data_2.max())
    if np.any(mask):
        out[mask] = spline2(j[mask])
    return out if out.shape != () else out.item()


# -------------------------------------------------------------------
# Combine splines to function eta_of_P
# --------------------------------------------------------------------
P_cropped = P_data[0:-1]
j_cropped = j_data_2[0:-1]
eta_cropped = eta_of_j(j_cropped)
print(eta_cropped)



spline_eta_of_P = CubicSpline(P_cropped, eta_cropped, bc_type='natural', extrapolate=True)
filepath = 'fc/spline_eta_of_P.pkl'
with open(filepath, 'wb') as f:
    pickle.dump(da_realest_spline, f, protocol=pickle.HIGHEST_PROTOCOL)


def eta_of_P(P):
    """
    Return the interpolated energy‐efficiency [%%] at power P [W]
    using a cubic‐spline based on the digitized T=473 K curve.
    Returns NaN if P < 0 or P > 9037.036895751953 (no extrapolation).
    """
    P = np.atleast_1d(P)
    out = np.full_like(P, np.nan, dtype=float)
    mask = (P >= P_data_realest.min()) & (P <= P_data_realest.max())
    if np.any(mask):
        out[mask] = da_realest_spline(P[mask])
    return out if out.shape != () else out.item()

def V_of_i(i):
    """
    Return the interpolated current density [A/m²] at voltage V [V]
    using a cubic‐spline based on the digitized T=473 K curve.
    Returns NaN if i < 0 or i > 1.38 (no extrapolation).
    """
    i = np.atleast_1d(i)
    out = np.full_like(i, np.nan, dtype=float)
    mask = (i >= da_realest_spline2.x.min()) & (i <= da_realest_spline2.x.max())
    if np.any(mask):
        out[mask] = da_realest_spline2(i[mask])
    return out if out.shape != () else out.item()
    



# -------------------------------------------------------------------
# 3) (Optional) Quick plot to verify.
# -------------------------------------------------------------------
if __name__ == "__main__":
    # Plot original "dots" and the continuous spline
    P_dense = np.linspace(0, 1, 500)
    eta_dense = eta_of_P(P_dense)

    # j_dense = np.linspace(0, 1, 500)
    # eta_dense_j = eta_of_j(j_dense * 20000)
    plt.figure(figsize=(4,2.5))
    # plt.plot(P_data_realest, eta_data_realest, 's', label="Digitized points (473 K)")
    plt.plot(P_dense, eta_dense, '-')
    # plt.plot(j_dense , eta_dense_j, '-', label="Cubic‐spline, η(j)")
    plt.plot()
    plt.xlabel("Throttle [%]")
    plt.ylabel("Efficiency [%] (LHV)")
    # plt.title("Power vs Efficiency of Fuel Cell")
    plt.grid(True, alpha=0.3)
    # plt.legend()
    plt.tight_layout()
    plt.show()
    # # Example usage:
    # for test_j in [0, 1000, 5000, 10000, 15000, 20000]:
    #     print(f"η({test_j:.0f} A/m)  {eta_of_j(test_j):.2f} %")


    V = V_of_i(i)
    P = P_of_j(i)
    plt.figure(figsize=(4,2.5))
    fig, ax1 = plt.subplots(figsize=(4,2.5))
    
    color = 'tab:red'
    ax1.set_xlabel('Current Density [A/cm²]')
    ax1.set_ylabel('Voltage [V]', color=color)
    ax1.plot(i, V, color=color)
    ax1.tick_params(axis='y', labelcolor=color)

    ax2 = ax1.twinx()  # instantiate a second Axes that shares the same x-axis

    color = 'tab:blue'
    ax2.set_ylabel('Power Density [W/cm²]', color=color)  # we already handled the x-label with ax1
    ax2.plot(i, P_data_realest2, color=color)
    ax2.tick_params(axis='y', labelcolor=color)

    fig.tight_layout()  # otherwise the right y-label is slightly clipped
    plt.show()




